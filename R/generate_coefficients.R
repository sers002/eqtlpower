#' Generate eQTL coefficients based on Summary Statistics and Linkage
#' Disequilibrium
#'
#' This function generates a series of realisations of the SNP-gene association
#' coefficients based on the true association value (\code{beta}) and the
#' linkage disequilibrium that exists between variants.
#'
#' @param associations A dataset of associations to simulate.
#' @param ld A linkage disequilibrium dataset generated by PLINK.
#' @param sample_sizes A vector of sample sizes to test.
#' @param reps Number of realisations to generate.
#' @param verbose If \code{TRUE}, messages will be output during the course of
#' the function.
#' @param seed The random seed that will be set before generating coefficients
#' @param var_y The variance of the response
#'
#' @return A dataset containing metadata for each gene-SNP association with
#' \code{reps} columns where each is a realisation.
#' @export
#'
#' @examples
#' \donttest{
#' data("associations")
#' data("ld")
#'
#' sa_coefs <- generate_coefficients(associations.dt, ld.dt)
#' }
generate_coefficients <- function(
  associations,
  ld,
  var_y = 1,
  sample_sizes = c(50, 100, 250, 500),
  reps = 100,
  verbose = TRUE,
  seed = 12345
) {
  var_error <-
    maf <-
    n_snps <-
    pid <-
    SNP_A <-
    SNP_B <-
    NULL

  coef_results <- data.table::data.table()

  associations <- data.table::data.table(associations)
  associations[, var_error := var_y - (beta^2 * 2 * maf * (1 - maf))]
  associations <- associations[var_error > 0]

  ld <- data.table::data.table(ld)

  gene_list <- associations[, list(n_snps = .N), by = "pid"][order(-n_snps)]$pid

  if (verbose) {
    message(" Number of realisations:  ", reps)
    message(" Range of error variance: ", prettyNum(min(associations$var_error)), " - ", prettyNum(max(associations$var_error)))
    message(" Number of genes:         ", prettyNum(length(gene_list), big.mark = ","))
    message("")
  }

  set.seed(seed = seed)

  for (g.i in seq_along(gene_list)) {
    curr_gene <- gene_list[g.i]

    associations_gene <- associations[pid == curr_gene]

    if (verbose) {
      message(
        " ", g.i, ": ", curr_gene, " (", prettyNum(nrow(associations_gene), big.mark = ","), " associations)"
      )
    }

    ld_sub_mat <- Matrix.utils::dMcast(
      ld[SNP_A %in% associations_gene$snp & SNP_B %in% associations_gene$snp],
      SNP_A ~ SNP_B,
      value.var = "R"
    )
    colnames(ld_sub_mat) <- gsub("SNP_B", "", colnames(ld_sub_mat))

    ld_sub_mat <- ld_sub_mat[associations_gene$snp, associations_gene$snp]

    for (N in sample_sizes) {
      if (verbose) {
        message("  N = ", N)
      }

      ## The one SNP situation is slightly different
      if (nrow(associations_gene) == 1) {
        sigma_mat <- as.matrix(
          associations_gene$var_error/(2 * N * associations_gene$maf * (1-associations_gene$maf))
        )
      } else {
        ## Calculated as sigma_mat[i, j] = sqrt(var_beta_i) * sqrt(var_beta_j) * r_ij
        se_betas <- sqrt(
          associations_gene$var_error/(2 * N * associations_gene$maf * (1-associations_gene$maf))
        )

        sigma_mat <- sweep(ld_sub_mat, MARGIN = 1, STATS = se_betas, FUN = "*")
        sigma_mat <- sweep(sigma_mat,  MARGIN = 2, STATS = se_betas, FUN = "*")
      }

      ## Simulate 100 realisations of the semi-analytic betas
      sim_betas <- mvtnorm::rmvnorm(
        n = reps,
        mean = associations_gene$beta,
        sigma = sigma_mat,
        checkSymmetry = FALSE
      )

      ## Turn it into rows = SNPs, columns = realisations
      sim_betas <- t(sim_betas)

      sim.dt <- data.table(
        pid = associations_gene$pid,
        snp = associations_gene$snp,
        sample_size = N,
        sim_betas
      )

      coef_results <- rbind(
        coef_results,
        sim.dt
      )
    }

    if (verbose) {
      message("")
    }

    rm(ld_sub_mat, sim_betas, sim.dt)
    gc()
  }

  coef_results
}
